#include "exploits.h"
#include "../../core/hooks.h"

bool CExploits::ShouldRecharge( ) {
    const auto ticksToCharge{ 14 - int( std::min( Interfaces::Globals->flAbsFrameTime, Interfaces::Globals->flFrameTime ) / Interfaces::Globals->flIntervalPerTick ) };

    if ( ctx.m_iTicksAllowed >= ticksToCharge )
        return false;

    if ( Features::Exploits.m_iRechargeCmd == Interfaces::ClientState->iLastOutgoingCommand ) {
        ++ctx.m_iTicksAllowed;
        return true;
    }

    if ( !ctx.m_bExploitsEnabled )
        return false;

    if ( Config::Get<bool>( Vars.MiscFakeDuck ) && Config::Get<keybind_t>( Vars.MiscFakeDuckKey ).enabled )
        return false;

    if ( ( Interfaces::Globals->flCurTime - ctx.m_pLocal->m_flSpawnTime( ) ) < 1.f )
        return false;

    //if ( ctx.m_iTicksAllowed >= 13 && Features::Exploits.m_iRechargeCmd != Interfaces::ClientState->iLastOutgoingCommand )
    //    return false;

    if ( std::abs( Interfaces::Globals->flRealTime - ctx.m_iLastStopTime ) < 0.3f )
        return false;

    if ( Features::Ragebot.m_bShouldStop )
        return false;

    if ( m_iShiftAmount )
        return false;

    const auto extraTicks{ **( int** ) Displacement::Sigs.numticks - **( int** ) Displacement::Sigs.host_currentframetick };
    if ( ( ticksToCharge - ctx.m_iTicksAllowed ) + extraTicks + Interfaces::ClientState->nChokedCommands >= 16 ) {
        ctx.m_bSendPacket = true;
        return false;
    }

    Features::Exploits.m_iRechargeCmd = Interfaces::ClientState->iLastOutgoingCommand;

    ++ctx.m_iTicksAllowed;

    return true;
}

int CExploits::AdjustTickbase( const int totalNewCmds, bool* corrected ) {
    const auto tickCount{ Interfaces::ClientState->iServerTick + ctx.m_iRealOutLatencyTicks + 1 };

    const auto correctionTicks{ ctx.CalcCorrectionTicks( ) };
    if ( correctionTicks != -1 ) {
        const auto idealFinalTick{ tickCount + correctionTicks };

        const auto estimatedFinalTick{ m_iServerTickbase + totalNewCmds };

        if ( estimatedFinalTick <= idealFinalTick + correctionTicks
            && estimatedFinalTick >= tickCount )
            return m_iServerTickbase;

        if ( corrected )
            *corrected = true;

        return idealFinalTick - totalNewCmds;
    }
    else
        return tickCount - totalNewCmds;
}

void CExploits::Shift( bf_write* buf, MoveMsg_t* moveMsg ) {
    Features::Exploits.m_bWasDefensiveTick = false;
    ctx.m_bSafeFromDefensive = false;

    const auto newCmds{ std::min( moveMsg->m_iNewCmds + std::min( m_iShiftAmount, ctx.m_iTicksAllowed ), 16 ) };

    auto maxShiftedCmds{ newCmds - moveMsg->m_iNewCmds };

    if ( m_bRealCmds )
        ctx.m_iTicksAllowed -= std::max( maxShiftedCmds, ctx.m_iTicksAllowed );
    else
        ctx.m_iTicksAllowed = std::max( maxShiftedCmds, 0 );

    moveMsg->m_iNewCmds = std::clamp( moveMsg->m_iNewCmds + maxShiftedCmds, 1, 62 );

    const auto nextCmdNumber{ Interfaces::ClientState->iLastOutgoingCommand + Interfaces::ClientState->nChokedCommands + 1 };

    const auto userCmd = Interfaces::Input->GetUserCmd( nextCmdNumber );
    if ( !userCmd )
        return;

    auto toUserCmd{ *userCmd };

    if ( m_bRealCmds ) {
        auto shouldStop{ false };

        const float yaw{ std::remainderf( Features::Antiaim.BaseYaw( toUserCmd ), 360.f ) };

        while ( maxShiftedCmds > 0 ) {
            ++Interfaces::ClientState->nChokedCommands;
            ++Interfaces::ClientState->pNetChannel->iChokedPackets;
            ++Interfaces::ClientState->pNetChannel->iOutSequenceNr;
            toUserCmd.iCommandNumber = Interfaces::ClientState->iLastOutgoingCommand + Interfaces::ClientState->nChokedCommands + 1;

            auto& localData{ ctx.m_cLocalData.at( toUserCmd.iCommandNumber % 150 ) };
            localData.Save( ctx.m_pLocal, toUserCmd, ctx.m_pWeapon );
            localData.m_iCommandNumber = toUserCmd.iCommandNumber;

            ctx.m_flFixedCurtime = TICKS_TO_TIME( ctx.m_pLocal->m_nTickBase( ) );

            --maxShiftedCmds;

            Interfaces::Globals->flCurTime = ctx.m_flFixedCurtime;

            toUserCmd.iButtons &= ~( IN_ATTACK | IN_ATTACK2 | IN_BULLRUSH | IN_SPEED | IN_WALK | IN_ZOOM | IN_JUMP );
            //toUserCmd.iButtons &= ~( 0x801u );
            toUserCmd.flForwardMove = Features::Misc.m_ve2OldMovement.x;
            toUserCmd.flSideMove = Features::Misc.m_ve2OldMovement.y;
            toUserCmd.viewAngles = ctx.m_angOriginalViewangles;

            localData.SavePredVars( ctx.m_pLocal, toUserCmd );

            if ( maxShiftedCmds <= 5 && !shouldStop ) {
                ctx.m_vecEyePos = ctx.m_pLocal->GetEyePosition( ctx.m_angOriginalViewangles.y, ctx.m_angOriginalViewangles.x );
                ctx.m_bCanShoot = ctx.m_pLocal->CanShoot( );

                Features::Ragebot.Main( toUserCmd, false );

                shouldStop = Features::Ragebot.m_bShouldStop;
            }

            if ( ctx.m_pLocal->m_MoveType( ) == MOVETYPE_WALK ) {
                if ( Config::Get<bool>( Vars.MiscBunnyhop ) && Features::Misc.m_bWasJumping ) {
                    if ( ctx.m_pLocal->m_fFlags( ) & FL_ONGROUND )
                        toUserCmd.iButtons |= IN_JUMP;
                }
                else if ( !Features::Misc.MicroMove( toUserCmd ) ) {
                    if ( shouldStop )
                        Features::Misc.AutoStop( toUserCmd );
                    else
                        Features::Misc.SlowWalk( toUserCmd );
                }
            }

            const auto backupCS{ ctx.m_bCanShoot };
            ctx.m_bCanShoot = false;
            Features::Misc.AutoPeek( toUserCmd );
            ctx.m_bCanShoot = backupCS;

            Features::EnginePrediction.RunCommand( toUserCmd );
            Features::EnginePrediction.Finish( );

            //Features::Misc.NormalizeMovement( toUserCmd );

            Interfaces::Input->pCommands[ toUserCmd.iCommandNumber % 150 ] = toUserCmd;
            Interfaces::Input->pVerifiedCommands[ toUserCmd.iCommandNumber % 150 ].userCmd = toUserCmd;
            Interfaces::Input->pVerifiedCommands[ toUserCmd.iCommandNumber % 150 ].uHashCRC = toUserCmd.GetChecksum( );
        }

        Interfaces::Prediction->iPreviousStartFrame = -1;
        Interfaces::Prediction->Split->nCommandsPredicted = 0;
        //Interfaces::Prediction->Split->nServerCommandsAcknowledged = 0xFADED;

        ctx.m_cFakeData.m_sState = *ctx.m_pLocal->m_pAnimState( );
        std::memcpy( ctx.m_pAnimationLayers, ctx.m_pLocal->m_AnimationLayers( ), 13 * sizeof CAnimationLayer );
    }
    else {
        toUserCmd.iTickCount = INT_MAX;
        toUserCmd.iCommandNumber = 0;

        toUserCmd.iCommandNumber = Interfaces::ClientState->iLastOutgoingCommand + Interfaces::ClientState->nChokedCommands + 1;

        while ( maxShiftedCmds ) {
            Interfaces::Input->pCommands[ ++toUserCmd.iCommandNumber % 150 ] = toUserCmd;
            Interfaces::Input->pVerifiedCommands[ toUserCmd.iCommandNumber % 150 ].userCmd = toUserCmd;
            Interfaces::Input->pVerifiedCommands[ toUserCmd.iCommandNumber % 150 ].uHashCRC = toUserCmd.GetChecksum( );

            --maxShiftedCmds;
        }
    }

    m_iShiftAmount = 0;
}

void CExploits::BreakLC( bf_write* buf, int shift, MoveMsg_t* moveMsg ) {
    const auto nextCmdNumber{ Interfaces::ClientState->iLastOutgoingCommand + Interfaces::ClientState->nChokedCommands + 1 };

    const auto newCmds{ std::min( moveMsg->m_iNewCmds + shift, 16 ) };

    auto maxShiftedCmds{ newCmds - moveMsg->m_iNewCmds };
    ctx.m_iTicksAllowed = std::max( maxShiftedCmds, 0 );

    moveMsg->m_iNewCmds = std::clamp( moveMsg->m_iNewCmds + maxShiftedCmds, 1, 62 );

    const auto user_cmd = Interfaces::Input->GetUserCmd( nextCmdNumber );
    if ( !user_cmd )
        return;

    auto toUserCmd{ *user_cmd };

    toUserCmd.iTickCount = INT_MAX;

    toUserCmd.iCommandNumber = Interfaces::ClientState->iLastOutgoingCommand + Interfaces::ClientState->nChokedCommands + 1;

    while ( maxShiftedCmds ) {
        Interfaces::Input->pCommands[ ++toUserCmd.iCommandNumber % 150 ] = toUserCmd;
        Interfaces::Input->pVerifiedCommands[ toUserCmd.iCommandNumber % 150 ].userCmd = toUserCmd;
        Interfaces::Input->pVerifiedCommands[ toUserCmd.iCommandNumber % 150 ].uHashCRC = toUserCmd.GetChecksum( );

        --maxShiftedCmds;
    }
}

void CExploits::BreakCBB( bf_write* buf, MoveMsg_t* moveMsg ) {
    const auto nextCmdNumber{ Interfaces::ClientState->iLastOutgoingCommand + Interfaces::ClientState->nChokedCommands + 1 };

    moveMsg->m_iNewCmds += 1;

    const auto user_cmd = Interfaces::Input->GetUserCmd( nextCmdNumber );
    if ( !user_cmd )
        return;

    auto toUserCmd{ *user_cmd };

    //toUserCmd.iTickCount = INT_MAX;

    toUserCmd.iCommandNumber = Interfaces::ClientState->iLastOutgoingCommand + moveMsg->m_iNewCmds + 1;

    Interfaces::Input->pCommands[ toUserCmd.iCommandNumber % 150 ] = toUserCmd;
    Interfaces::Input->pVerifiedCommands[ toUserCmd.iCommandNumber % 150 ].userCmd = toUserCmd;
    Interfaces::Input->pVerifiedCommands[ toUserCmd.iCommandNumber % 150 ].uHashCRC = toUserCmd.GetChecksum( );
}